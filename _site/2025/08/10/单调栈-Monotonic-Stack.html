<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>单调栈 (Monotonic Stack)</title>
   <meta name="author" content="Sitan Chen />
   <link href="http://feeds.feedburner.com/tom-preston-werner" rel="alternate" title="Sitan Chen" type="application/atom+xml" />
   <meta name="readability-verification" content="QCzSs992GxmRYRKVpPeZ6LE2tS8aYKxsSSQKV8YM"/>

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Typekit -->
   <script type="text/javascript" src="http://use.typekit.com/jpd0pfm.js"></script>
   <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body>

<!-- ClickTale Top part -->
<script type="text/javascript">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class="site">
  <div class="title">
    <a href="/">Sitan Chen</a>
    <a class="extra" href="/">home</a>
  </div>

  <div id="post">
<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<h2 id="单调栈">单调栈</h2>

<h5 id="简介"><strong>简介</strong></h5>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<h5 id="实现"><strong>实现</strong></h5>

<h6 id="模版洛谷p5788"><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></h6>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n).
\(数据范围:n \leq 3 \times 10^6\)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2.</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5.</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[]数组记录答案</li>
  <li>从数列的右边向左边处理</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i).</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0.</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>变形:</strong></p>

<p>Example 1: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p>Example 2: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4		8		3		5		7		1		9		6
				    l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>

<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p>Example 3: <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形。输入每个矩形的高。</p>

<p><img src="/Users/stanchen/Library/Application Support/typora-user-images/image-20250810163310269.png" alt="image-20250810163310269" /></p>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>


</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>08 Aug 2025</span> &raquo; <a href="/2025/08/08/no-1.html">数独优化(Sudoku Optimization)</a></li>
    
      <li><span>17 Nov 2008</span> &raquo; <a href="/2008/11/17/blogging-like-a-hacker.html">Blogging Like a Hacker</a></li>
    
      <li><span>17 Nov 2008</span> &raquo; <a href="/2008/11/17/blogging-like-a-hacker-(Copy).html">Blogging Like a Hacker</a></li>
    
  </ul>
</div>

  <div class="footer">
    <div class="contact">
      <p>
        Sitan Chen
        <br />
        If you have the same hobbies, you can contact me. 
        <br />
        xstchen@outlook.com
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="http://github.com/miwaishi/">github.com/miwaishi</a><br />
        
      </p>
    </div>
    <div class="rss">
      
        <img src="/images/rss.png" alt="Subscribe to RSS Feed" />
      </a>
    </div>
  </div>
</div>



<!-- ClickTale Bottom part -->
<div id="ClickTaleDiv" style="display: none;"></div>
<script type="text/javascript">
if(document.location.protocol!='https:')
  document.write(unescape("%3Cscript%20src='http://s.clicktale.net/WRb.js'%20type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
if(typeof ClickTale=='function') ClickTale(206,0.3,"www03");
</script>
<!-- ClickTale end of Bottom part -->

<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-6016902-1");
pageTracker._trackPageview();
</script>
<!-- Google Analytics end -->

</body>
</html>
